<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Plus Formen - Linear Fade</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        canvas { display: block; }
        
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 14px;
            opacity: 0.8;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 60px;
            color: white;
            z-index: 10;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            padding-bottom: 40px;
            padding-top: 40px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            color: #aaa;
            margin-bottom: 5px;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
            transition: transform 0.1s;
            margin-top: 0;
        }
        
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #00ffff;
        }

        input[type=range]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Scrollen: Zum Logo fliegen</div>
    
    <div id="controls">
        <!-- Regler 1: Maximale Unschärfe bei Z=0 (Kamera) -->
        <div class="control-group">
            <label for="blurSlider">Intensität (Max Blur bei Kamera)</label>
            <input type="range" id="blurSlider" min="0" max="100" value="50">
        </div>

        <!-- Regler 2: Wo endet der Blur? -->
        <div class="control-group">
            <label for="focusSlider">Blur-Ende (Tiefe)</label>
            <!-- Wertebereich angepasst für die Szene (Logo ist bei 500 Distanz) -->
            <input type="range" id="focusSlider" min="50" max="600" value="300">
        </div>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

        let camera, scene, renderer, composer, bokehPass;
        const plusShapes = []; 

        const LOGO_Z = -500;
        const LOGO_HEIGHT = 4; 
        const TARGET_DISTANCE = 57;
        const MIN_Z = LOGO_Z + TARGET_DISTANCE; 

        // --- Steuerungsvariablen ---
        let targetZ = 40;     
        const START_Z = 40;   
        const MAX_Z = 150;    
        
        const SCROLL_SENSITIVITY = 0.15; 
        const EASE_FACTOR = 0.08;       

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 10, 600);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = START_Z;
            targetZ = START_Z;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); 
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(0, 2, 10).normalize();
            scene.add(directionalLight);

            // --- PLUS FORMEN ---
            const geometryV = new THREE.PlaneGeometry(1, 4);
            const geometryH = new THREE.PlaneGeometry(4, 1);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.7,
                metalness: 0.1,
                emissive: 0x000000,
                side: THREE.DoubleSide 
            });

            for (let i = 0; i < 200; i++) {
                const group = new THREE.Group();
                const meshV = new THREE.Mesh(geometryV, material);
                const meshH = new THREE.Mesh(geometryH, material);
                meshH.position.z = 0.01;

                group.add(meshV);
                group.add(meshH);

                group.position.x = (Math.random() - 0.5) * 120;
                group.position.y = (Math.random() - 0.5) * 100;
                group.position.z = 50 - Math.random() * 450; 

                scene.add(group);
                plusShapes.push(group);
            }

            // --- SVG LOGO ---
            loadBackgroundSVG();

            initPostProcessing();

            // Event Listener
            const blurSlider = document.getElementById('blurSlider');
            const focusSlider = document.getElementById('focusSlider');

            blurSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (bokehPass) {
                    bokehPass.uniforms['aperture'].value = value * 0.00001; 
                }
            });

            focusSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (bokehPass) {
                    bokehPass.uniforms['focus'].value = value;
                }
            });

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('wheel', onMouseWheel);
        }

        function loadBackgroundSVG() {
            const mySVG = `
            <svg id="Logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80.24 40.12">
              <defs>
                <style>
                  .cls-1 {
                    fill: #fff;
                  }
                </style>
              </defs>
              <path class="cls-1" d="M77.96,10.82c-3.35-6.42-10.06-10.82-17.81-10.82h-23.6v16.5h-16.49v7.11h16.49v9.39h-16.48c-2.89,0-5.55-.96-7.7-2.56-3.18-2.36-5.26-6.13-5.26-10.39,0-7.15,5.81-12.95,12.96-12.95h8.24V0h-8.24C9,0,0,8.98,0,20.06c0,3.79,1.1,7.34,2.98,10.39,3.54,5.76,9.88,9.67,17.1,9.67h40.07c7.28,0,13.66-3.94,17.19-9.77,1.82-3.02,2.9-6.53,2.9-10.29,0-3.34-.83-6.47-2.27-9.24ZM68,30.35c-2.18,1.66-4.89,2.66-7.84,2.66h-16.47v-9.39h16.5v-7.11h-16.5V7.11h16.47c3.53,0,6.73,1.42,9.07,3.7,2.4,2.35,3.89,5.62,3.89,9.24,0,4.2-2.01,7.92-5.12,10.29Z"/>
            </svg>
            `;

            const svgUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(mySVG);

            const loader = new SVGLoader();
            loader.load(
                svgUrl,
                function (data) {
                    const paths = data.paths;
                    const group = new THREE.Group();

                    for (let i = 0; i < paths.length; i++) {
                        const path = paths[i];
                        const material = new THREE.MeshBasicMaterial({
                            color: path.color || 0xffffff,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });

                        const shapes = SVGLoader.createShapes(path);

                        for (let j = 0; j < shapes.length; j++) {
                            const shape = shapes[j];
                            const geometry = new THREE.ShapeGeometry(shape);
                            const mesh = new THREE.Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }

                    group.scale.set(1, -1, 1); 
                    const box = new THREE.Box3().setFromObject(group);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    group.position.x = -center.x;
                    group.position.y = -center.y; 
                    group.position.z = LOGO_Z; 

                    const desiredHeight = LOGO_HEIGHT; 
                    const scaleFactor = desiredHeight / size.y;
                    
                    group.scale.x *= scaleFactor;
                    group.scale.y *= scaleFactor;
                    group.scale.z *= scaleFactor;

                    scene.add(group);
                }
            );
        }

        function initPostProcessing() {
            const renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * window.devicePixelRatio,
                window.innerHeight * window.devicePixelRatio,
                { 
                    type: THREE.HalfFloatType,
                    samples: 8 
                }
            );

            composer = new EffectComposer(renderer, renderTarget);
            composer.setPixelRatio(window.devicePixelRatio); 
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Initialwerte
            const initialFocus = 300.0; 
            const initialAperture = 50 * 0.00001; 

            bokehPass = new BokehPass(scene, camera, {
                focus: initialFocus,
                aperture: initialAperture,
                maxblur: 0.02, 
            });

            // -------------------------------------------------------------------------
            // SHADER HACK FÜR LINEAREN VERLAUF (One-Sided Blur)
            // -------------------------------------------------------------------------
            // Der Standard-Shader berechnet den Blur als Distanz in BEIDE Richtungen: 
            // abs(depth - focalDepth).
            // Wir ändern das im Shader-Code zu: max(focalDepth - depth, 0.0).
            // Das bedeutet: 
            // Wenn Tiefe < Fokus (näher zur Kamera) -> Blur.
            // Wenn Tiefe > Fokus (weiter weg) -> Kein Blur (0.0).
            // -------------------------------------------------------------------------
            
            const materialBokeh = bokehPass.materialBokeh;
            
            // Wir verwenden einen Regex, um die Stelle im minifizierten oder normalen Code zu finden
            // Standard Three.js Shader: abs( depth - fDepth )
            materialBokeh.fragmentShader = materialBokeh.fragmentShader.replace(
                /abs\s*\(\s*depth\s*-\s*fDepth\s*\)/g, 
                'max(fDepth - depth, 0.0)'
            );
            
            // Shader muss neu kompiliert werden
            materialBokeh.needsUpdate = true;

            // Werte setzen
            bokehPass.uniforms['focus'].value = initialFocus; 
            bokehPass.uniforms['aperture'].value = initialAperture; 
            bokehPass.uniforms['maxblur'].value = 0.02;

            composer.addPass(bokehPass);
        }

        function onMouseWheel(event) {
            const scrollAmount = event.deltaY * SCROLL_SENSITIVITY;
            targetZ -= scrollAmount; 
            targetZ = Math.max(MIN_Z, Math.min(MAX_Z, targetZ));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            composer.setSize(window.innerWidth, window.innerHeight);
            composer.setPixelRatio(window.devicePixelRatio);
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.position.z += (targetZ - camera.position.z) * EASE_FACTOR;
            composer.render();
        }
    </script>
</body>
</html>
